{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u041e\u0442\u0447\u0435\u0442\u044b \u043f\u043e \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u043c \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u044b \"\u0421\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0432\u0435\u0431-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\"","title":"\u041e\u0442\u0447\u0435\u0442\u044b \u043f\u043e \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u043c \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u044b \"\u0421\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0432\u0435\u0431-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\""},{"location":"#-","text":"","title":"\u041e\u0442\u0447\u0435\u0442\u044b \u043f\u043e \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u043c \u0440\u0430\u0431\u043e\u0442\u0430\u043c \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\u044b \"\u0421\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0432\u0435\u0431-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\""},{"location":"lab1/configuration/","text":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0435\u043a\u0442\u0430 models - \u0432\u0441\u0435 \u043c\u043e\u0434\u0435\u043b\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. user_endpoints - CRUD \u043c\u043e\u0434\u0435\u043b\u0435\u0439 user_endpoints - \u041f\u0443\u0442\u0438 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u044e\u0437\u0435\u0440\u043e\u043c. main - \u0437\u0430\u043f\u0443\u0441\u043a \u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0435\u043a\u0442\u0430","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0435\u043a\u0442\u0430"},{"location":"lab1/configuration/#_1","text":"models - \u0432\u0441\u0435 \u043c\u043e\u0434\u0435\u043b\u0438 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f. user_endpoints - CRUD \u043c\u043e\u0434\u0435\u043b\u0435\u0439 user_endpoints - \u041f\u0443\u0442\u0438 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u044e\u0437\u0435\u0440\u043e\u043c. main - \u0437\u0430\u043f\u0443\u0441\u043a \u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044f \u043f\u0440\u043e\u0435\u043a\u0442\u0430","title":"\u041a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0435\u043a\u0442\u0430"},{"location":"lab1/endpoints/","text":"CRUD \u044d\u043d\u0434\u0440\u043e\u0438\u043d\u0442\u044b import datetime from fastapi import APIRouter, HTTPException from fastapi import Depends from schemas import (Salary, SalaryDB, SalaryDisplay,SalaryPeriod, SalaryPeriodDisplay, SalaryPeriodDB, SalaryPeriodForUser, SalaryPeriodForUserDB, SalaryPeriodForUserDisplay, WasteDB, WasteDisplay, Waste, WastePeriodDisplay, WastePeriodDB, WastePeriod, WastePeriodForUser, WastePeriodForUserDB, WastePeriodForUserDisplay) from db import get_session from typing_extensions import TypedDict logic_router = APIRouter() @logic_router.post(\"/waste_period_for_user-create\") def wp_user_create(wp_user: WastePeriodForUserDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": WastePeriodForUser}): wp_user = WastePeriodForUser.model_validate(wp_user) session.add(wp_user) session.commit() session.refresh(wp_user) return {\"status\": 200, \"data\": wp_user} @logic_router.get(\"/list-waste_period_for_user\") def wp_users_list(session=Depends(get_session)) -> list[WastePeriodForUser]: return session.query(WastePeriodForUser).all() @logic_router.get(\"/waste_period_for_user/{wp_user_id}\", response_model=WastePeriodForUserDisplay) def wp_user_get(wp_user_id: int, session=Depends(get_session)): obj = session.get(WastePeriodForUser, wp_user_id) if obj is None: raise HTTPException(status_code=404, detail=\"waste period not found\") return obj @logic_router.patch(\"/waste_period_for_user/update/{wp_user_id}\") def wp_user_update(wp_user_id: int, wp_user: WastePeriodForUserDB, session=Depends(get_session)) -> \\ WastePeriodForUser: db_wp_user = session.get(WastePeriodForUser, wp_user_id) if not db_wp_user: raise HTTPException(status_code=404, detail=\"waste period not found\") wp_user_data = wp_user.model_dump(exclude_unset=True) for key, value in wp_user_data.items(): setattr(db_wp_user, key, value) session.add(db_wp_user) session.commit() session.refresh(db_wp_user) return db_wp_user @logic_router.delete(\"/waste_period_for_user/delete/{wp_user_id}\") def wp_user_delete(wp_user_id: int, session=Depends(get_session)): wp_user = session.get(WastePeriodForUser, wp_user_id) if not wp_user: raise HTTPException(status_code=404, detail=\"wp_user not found\") session.delete(wp_user) session.commit() return {\"ok\": True} ######### @logic_router.post(\"/salary_period_for_user-create\") def sp_user_create(sp_user: SalaryPeriodForUserDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": SalaryPeriodForUser}): sp_user = SalaryPeriodForUser.model_validate(sp_user) session.add(sp_user) session.commit() session.refresh(sp_user) return {\"status\": 200, \"data\": sp_user} @logic_router.get(\"/list-salary_period_for_user\") def sp_users_list(session=Depends(get_session)) -> list[SalaryPeriodForUser]: return session.query(SalaryPeriodForUser).all() @logic_router.get(\"/salary_period_for_user/{sp_user_id}\", response_model=SalaryPeriodForUserDisplay) def sp_user_get(sp_user_id: int, session=Depends(get_session)): obj = session.get(SalaryPeriodForUser, sp_user_id) if obj is None: raise HTTPException(status_code=404, detail=\"salary period not found\") return obj @logic_router.patch(\"/salary_period_for_user/update/{sp_user_id}\") def sp_user_update(sp_user_id: int, sp_user: SalaryPeriodForUserDB, session=Depends(get_session)) -> \\ SalaryPeriodForUser: db_sp_user = session.get(SalaryPeriodForUser, sp_user_id) if not db_sp_user: raise HTTPException(status_code=404, detail=\"salary period not found\") sp_user_data = sp_user.model_dump(exclude_unset=True) for key, value in sp_user_data.items(): setattr(db_sp_user, key, value) session.add(db_sp_user) session.commit() session.refresh(db_sp_user) return db_sp_user @logic_router.delete(\"/salary_period_for_user/delete/{sp_user_id}\") def sp_user_delete(sp_user_id: int, session=Depends(get_session)): sp_user = session.get(SalaryPeriodForUser, sp_user_id) if not sp_user: raise HTTPException(status_code=404, detail=\"sp_user not found\") session.delete(sp_user) session.commit() return {\"ok\": True} ######## @logic_router.post(\"/waste_period-create\") def waste_period_create(period: WastePeriodDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": WastePeriod}): period = WastePeriod.model_validate(period) session.add(period) session.commit() session.refresh(period) return {\"status\": 200, \"data\": period} @logic_router.get(\"/list-waste_period\") def waste_periods_list(session=Depends(get_session)) -> list[WastePeriod]: return session.query(WastePeriod).all() @logic_router.get(\"/waste_period/{period_id}\", response_model=WastePeriodDisplay) def waste_period_get(period_id: int, session=Depends(get_session)): obj = session.get(WastePeriod, period_id) if obj is None: raise HTTPException(status_code=404, detail=\"subperiod not found\") return obj @logic_router.patch(\"/waste_period/update/{period_id}\") def waste_period_update(period_id: int, period: WastePeriodDB, session=Depends(get_session)) -> WastePeriod: db_period = session.get(period, period_id) if not db_period: raise HTTPException(status_code=404, detail=\"period not found\") period_data = period.model_dump(exclude_unset=True) for key, value in period_data.items(): setattr(db_period, key, value) session.add(db_period) session.commit() session.refresh(db_period) return db_period @logic_router.delete(\"/waste_period/delete/{period_id}\") def waste_period_delete(period_id: int, session=Depends(get_session)): period = session.get(WastePeriod, period_id) if not period: raise HTTPException(status_code=404, detail=\"period not found\") session.delete(period) session.commit() return {\"ok\": True} ######## @logic_router.post(\"/salary_period-create\") def salary_period_create(period: SalaryPeriodDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": SalaryPeriod}): period = SalaryPeriod.model_validate(period) session.add(period) session.commit() session.refresh(period) return {\"status\": 200, \"data\": period} @logic_router.get(\"/list-salary_period\") def salary_periods_list(session=Depends(get_session)) -> list[SalaryPeriod]: return session.query(SalaryPeriod).all() @logic_router.get(\"/salary_period/{period_id}\", response_model=SalaryPeriodDisplay) def salary_period_get(period_id: int, session=Depends(get_session)): obj = session.get(SalaryPeriod, period_id) if obj is None: raise HTTPException(status_code=404, detail=\"subperiod not found\") return obj @logic_router.patch(\"/salary_period/update/{period_id}\") def salary_period_update(period_id: int, period: SalaryPeriodDB, session=Depends(get_session)) -> SalaryPeriod: db_period = session.get(period, period_id) if not db_period: raise HTTPException(status_code=404, detail=\"period not found\") period_data = period.model_dump(exclude_unset=True) for key, value in period_data.items(): setattr(db_period, key, value) session.add(db_period) session.commit() session.refresh(db_period) return db_period @logic_router.delete(\"/salary_period/delete/{period_id}\") def salary_period_delete(period_id: int, session=Depends(get_session)): period = session.get(SalaryPeriod, period_id) if not period: raise HTTPException(status_code=404, detail=\"period not found\") session.delete(period) session.commit() return {\"ok\": True} ############### @logic_router.post(\"/waste-create\") def waste_create(input_data: WasteDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": Waste}): date = datetime.datetime.now() waste = Waste(type=input_data.type, date=date, value=input_data.value, waste_period_for_user_id=input_data.waste_period_for_user_id) session.add(waste) session.commit() session.refresh(waste) return {\"status\": 200, \"data\": waste} @logic_router.get(\"/list-wastes\") def wastes_list(session=Depends(get_session)) -> list[Waste]: return session.query(Waste).all() @logic_router.get(\"/waste/{waste_id}\", response_model=WasteDisplay) def waste_get(waste_id: int, session=Depends(get_session)): obj = session.get(Waste, waste_id) if obj is None: raise HTTPException(status_code=404, detail=\"waste not found\") return obj @logic_router.patch(\"/waste/update/{waste_id}\") def waste_update(waste_id: int, waste: WasteDB, session=Depends(get_session)) -> Waste: db_waste = session.get(waste, waste_id) if not db_waste: raise HTTPException(status_code=404, detail=\"waste not found\") waste_data = waste.model_dump(exclude_unset=True) for key, value in waste_data.items(): setattr(db_waste, key, value) session.add(db_waste) session.commit() session.refresh(db_waste) return db_waste @logic_router.delete(\"/waste/delete/{waste_id}\") def waste_delete(waste_id: int, session=Depends(get_session)): waste = session.get(Waste, waste_id) if not waste: raise HTTPException(status_code=404, detail=\"waste not found\") session.delete(waste) session.commit() return {\"ok\": True} ######### @logic_router.post(\"/salary-create\") def salary_create(input_data: SalaryDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": Salary}): date = datetime.datetime.now() salary = Salary(legal=input_data.legal, salary_period_for_user_id=input_data.salary_period_for_user_id, date=date, value=input_data.value) session.add(salary) session.commit() session.refresh(salary) return {\"status\": 200, \"data\": salary} @logic_router.get(\"/list-salarys\") def salary_list(session=Depends(get_session)) -> list[Salary]: return session.query(Salary).all() @logic_router.get(\"/salary/{salary_id}\", response_model=SalaryDisplay) def salary_get(salary_id: int, session=Depends(get_session)): obj = session.get(Salary, salary_id) if obj is None: raise HTTPException(status_code=404, detail=\"salary not found\") return obj @logic_router.patch(\"/salary/update/{salary_id}\") def salary_update(salary_id: int, salary: SalaryDB, session=Depends(get_session)) -> Salary: db_salary = session.get(Salary, salary_id) if not db_salary: raise HTTPException(status_code=404, detail=\"salary not found\") salary_data = salary.model_dump(exclude_unset=True) for key, value in salary_data.items(): setattr(db_salary, key, value) session.add(db_salary) session.commit() session.refresh(db_salary) return db_salary @logic_router.delete(\"/salary/delete/{salary_id}\") def salary_delete(salary_id: int, session=Depends(get_session)): salary = session.get(Salary, salary_id) if not salary: raise HTTPException(status_code=404, detail=\"salary not found\") session.delete(salary) session.commit() return {\"ok\": True}","title":"CRUD \u044d\u043d\u0434\u0440\u043e\u0438\u043d\u0442\u044b"},{"location":"lab1/endpoints/#crud","text":"import datetime from fastapi import APIRouter, HTTPException from fastapi import Depends from schemas import (Salary, SalaryDB, SalaryDisplay,SalaryPeriod, SalaryPeriodDisplay, SalaryPeriodDB, SalaryPeriodForUser, SalaryPeriodForUserDB, SalaryPeriodForUserDisplay, WasteDB, WasteDisplay, Waste, WastePeriodDisplay, WastePeriodDB, WastePeriod, WastePeriodForUser, WastePeriodForUserDB, WastePeriodForUserDisplay) from db import get_session from typing_extensions import TypedDict logic_router = APIRouter() @logic_router.post(\"/waste_period_for_user-create\") def wp_user_create(wp_user: WastePeriodForUserDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": WastePeriodForUser}): wp_user = WastePeriodForUser.model_validate(wp_user) session.add(wp_user) session.commit() session.refresh(wp_user) return {\"status\": 200, \"data\": wp_user} @logic_router.get(\"/list-waste_period_for_user\") def wp_users_list(session=Depends(get_session)) -> list[WastePeriodForUser]: return session.query(WastePeriodForUser).all() @logic_router.get(\"/waste_period_for_user/{wp_user_id}\", response_model=WastePeriodForUserDisplay) def wp_user_get(wp_user_id: int, session=Depends(get_session)): obj = session.get(WastePeriodForUser, wp_user_id) if obj is None: raise HTTPException(status_code=404, detail=\"waste period not found\") return obj @logic_router.patch(\"/waste_period_for_user/update/{wp_user_id}\") def wp_user_update(wp_user_id: int, wp_user: WastePeriodForUserDB, session=Depends(get_session)) -> \\ WastePeriodForUser: db_wp_user = session.get(WastePeriodForUser, wp_user_id) if not db_wp_user: raise HTTPException(status_code=404, detail=\"waste period not found\") wp_user_data = wp_user.model_dump(exclude_unset=True) for key, value in wp_user_data.items(): setattr(db_wp_user, key, value) session.add(db_wp_user) session.commit() session.refresh(db_wp_user) return db_wp_user @logic_router.delete(\"/waste_period_for_user/delete/{wp_user_id}\") def wp_user_delete(wp_user_id: int, session=Depends(get_session)): wp_user = session.get(WastePeriodForUser, wp_user_id) if not wp_user: raise HTTPException(status_code=404, detail=\"wp_user not found\") session.delete(wp_user) session.commit() return {\"ok\": True} ######### @logic_router.post(\"/salary_period_for_user-create\") def sp_user_create(sp_user: SalaryPeriodForUserDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": SalaryPeriodForUser}): sp_user = SalaryPeriodForUser.model_validate(sp_user) session.add(sp_user) session.commit() session.refresh(sp_user) return {\"status\": 200, \"data\": sp_user} @logic_router.get(\"/list-salary_period_for_user\") def sp_users_list(session=Depends(get_session)) -> list[SalaryPeriodForUser]: return session.query(SalaryPeriodForUser).all() @logic_router.get(\"/salary_period_for_user/{sp_user_id}\", response_model=SalaryPeriodForUserDisplay) def sp_user_get(sp_user_id: int, session=Depends(get_session)): obj = session.get(SalaryPeriodForUser, sp_user_id) if obj is None: raise HTTPException(status_code=404, detail=\"salary period not found\") return obj @logic_router.patch(\"/salary_period_for_user/update/{sp_user_id}\") def sp_user_update(sp_user_id: int, sp_user: SalaryPeriodForUserDB, session=Depends(get_session)) -> \\ SalaryPeriodForUser: db_sp_user = session.get(SalaryPeriodForUser, sp_user_id) if not db_sp_user: raise HTTPException(status_code=404, detail=\"salary period not found\") sp_user_data = sp_user.model_dump(exclude_unset=True) for key, value in sp_user_data.items(): setattr(db_sp_user, key, value) session.add(db_sp_user) session.commit() session.refresh(db_sp_user) return db_sp_user @logic_router.delete(\"/salary_period_for_user/delete/{sp_user_id}\") def sp_user_delete(sp_user_id: int, session=Depends(get_session)): sp_user = session.get(SalaryPeriodForUser, sp_user_id) if not sp_user: raise HTTPException(status_code=404, detail=\"sp_user not found\") session.delete(sp_user) session.commit() return {\"ok\": True} ######## @logic_router.post(\"/waste_period-create\") def waste_period_create(period: WastePeriodDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": WastePeriod}): period = WastePeriod.model_validate(period) session.add(period) session.commit() session.refresh(period) return {\"status\": 200, \"data\": period} @logic_router.get(\"/list-waste_period\") def waste_periods_list(session=Depends(get_session)) -> list[WastePeriod]: return session.query(WastePeriod).all() @logic_router.get(\"/waste_period/{period_id}\", response_model=WastePeriodDisplay) def waste_period_get(period_id: int, session=Depends(get_session)): obj = session.get(WastePeriod, period_id) if obj is None: raise HTTPException(status_code=404, detail=\"subperiod not found\") return obj @logic_router.patch(\"/waste_period/update/{period_id}\") def waste_period_update(period_id: int, period: WastePeriodDB, session=Depends(get_session)) -> WastePeriod: db_period = session.get(period, period_id) if not db_period: raise HTTPException(status_code=404, detail=\"period not found\") period_data = period.model_dump(exclude_unset=True) for key, value in period_data.items(): setattr(db_period, key, value) session.add(db_period) session.commit() session.refresh(db_period) return db_period @logic_router.delete(\"/waste_period/delete/{period_id}\") def waste_period_delete(period_id: int, session=Depends(get_session)): period = session.get(WastePeriod, period_id) if not period: raise HTTPException(status_code=404, detail=\"period not found\") session.delete(period) session.commit() return {\"ok\": True} ######## @logic_router.post(\"/salary_period-create\") def salary_period_create(period: SalaryPeriodDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": SalaryPeriod}): period = SalaryPeriod.model_validate(period) session.add(period) session.commit() session.refresh(period) return {\"status\": 200, \"data\": period} @logic_router.get(\"/list-salary_period\") def salary_periods_list(session=Depends(get_session)) -> list[SalaryPeriod]: return session.query(SalaryPeriod).all() @logic_router.get(\"/salary_period/{period_id}\", response_model=SalaryPeriodDisplay) def salary_period_get(period_id: int, session=Depends(get_session)): obj = session.get(SalaryPeriod, period_id) if obj is None: raise HTTPException(status_code=404, detail=\"subperiod not found\") return obj @logic_router.patch(\"/salary_period/update/{period_id}\") def salary_period_update(period_id: int, period: SalaryPeriodDB, session=Depends(get_session)) -> SalaryPeriod: db_period = session.get(period, period_id) if not db_period: raise HTTPException(status_code=404, detail=\"period not found\") period_data = period.model_dump(exclude_unset=True) for key, value in period_data.items(): setattr(db_period, key, value) session.add(db_period) session.commit() session.refresh(db_period) return db_period @logic_router.delete(\"/salary_period/delete/{period_id}\") def salary_period_delete(period_id: int, session=Depends(get_session)): period = session.get(SalaryPeriod, period_id) if not period: raise HTTPException(status_code=404, detail=\"period not found\") session.delete(period) session.commit() return {\"ok\": True} ############### @logic_router.post(\"/waste-create\") def waste_create(input_data: WasteDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": Waste}): date = datetime.datetime.now() waste = Waste(type=input_data.type, date=date, value=input_data.value, waste_period_for_user_id=input_data.waste_period_for_user_id) session.add(waste) session.commit() session.refresh(waste) return {\"status\": 200, \"data\": waste} @logic_router.get(\"/list-wastes\") def wastes_list(session=Depends(get_session)) -> list[Waste]: return session.query(Waste).all() @logic_router.get(\"/waste/{waste_id}\", response_model=WasteDisplay) def waste_get(waste_id: int, session=Depends(get_session)): obj = session.get(Waste, waste_id) if obj is None: raise HTTPException(status_code=404, detail=\"waste not found\") return obj @logic_router.patch(\"/waste/update/{waste_id}\") def waste_update(waste_id: int, waste: WasteDB, session=Depends(get_session)) -> Waste: db_waste = session.get(waste, waste_id) if not db_waste: raise HTTPException(status_code=404, detail=\"waste not found\") waste_data = waste.model_dump(exclude_unset=True) for key, value in waste_data.items(): setattr(db_waste, key, value) session.add(db_waste) session.commit() session.refresh(db_waste) return db_waste @logic_router.delete(\"/waste/delete/{waste_id}\") def waste_delete(waste_id: int, session=Depends(get_session)): waste = session.get(Waste, waste_id) if not waste: raise HTTPException(status_code=404, detail=\"waste not found\") session.delete(waste) session.commit() return {\"ok\": True} ######### @logic_router.post(\"/salary-create\") def salary_create(input_data: SalaryDB, session=Depends(get_session)) \\ -> TypedDict('Response', {\"status\": int, \"data\": Salary}): date = datetime.datetime.now() salary = Salary(legal=input_data.legal, salary_period_for_user_id=input_data.salary_period_for_user_id, date=date, value=input_data.value) session.add(salary) session.commit() session.refresh(salary) return {\"status\": 200, \"data\": salary} @logic_router.get(\"/list-salarys\") def salary_list(session=Depends(get_session)) -> list[Salary]: return session.query(Salary).all() @logic_router.get(\"/salary/{salary_id}\", response_model=SalaryDisplay) def salary_get(salary_id: int, session=Depends(get_session)): obj = session.get(Salary, salary_id) if obj is None: raise HTTPException(status_code=404, detail=\"salary not found\") return obj @logic_router.patch(\"/salary/update/{salary_id}\") def salary_update(salary_id: int, salary: SalaryDB, session=Depends(get_session)) -> Salary: db_salary = session.get(Salary, salary_id) if not db_salary: raise HTTPException(status_code=404, detail=\"salary not found\") salary_data = salary.model_dump(exclude_unset=True) for key, value in salary_data.items(): setattr(db_salary, key, value) session.add(db_salary) session.commit() session.refresh(db_salary) return db_salary @logic_router.delete(\"/salary/delete/{salary_id}\") def salary_delete(salary_id: int, session=Depends(get_session)): salary = session.get(Salary, salary_id) if not salary: raise HTTPException(status_code=404, detail=\"salary not found\") session.delete(salary) session.commit() return {\"ok\": True}","title":"CRUD \u044d\u043d\u0434\u0440\u043e\u0438\u043d\u0442\u044b"},{"location":"lab1/models/","text":"\u041c\u043e\u0434\u0435\u043b\u0438 \u0411\u0414 \u0412 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0438: User - \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0441\u0435\u0440\u0432\u0438\u0441\u0430 Salary - \u0417\u0430\u0440\u043f\u043b\u0430\u0442\u0430 SalaryPeriod - \u041f\u0435\u0440\u0438\u043e\u0434, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0437\u0430\u0440\u043f\u043b\u0430\u0442\u044b SalaryPeriodForUser - \u041f\u0435\u0440\u0438\u043e\u0434 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0437\u0430\u0440\u043f\u043b\u0430\u0442\u044b \u0434\u043b\u044f \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 Waste - \u0422\u0440\u0430\u0442\u044b WastePeriod - \u041f\u0435\u0440\u0438\u043e\u0434 \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0441\u0447\u0438\u0442\u0430\u044e\u0442\u0441\u044f \u0442\u0440\u0430\u0442\u044b WastePeriodForUser - \u041f\u0435\u0440\u0438\u043e\u0434 \u0442\u0440\u0430\u0442 \u0434\u043b\u044f \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 === \"User\" ```Python title=\"User\" class UserBase(SQLModel): username: str password: str class UserDisplay(UserBase): salary_periods_for_user: Optional[List[\"SalaryPeriodForUser\"]] = None waste_periods_for_user: Optional[List[\"WastePeriodForUser\"]] = None class User(UserBase, table=True): id: int = Field(default=None, primary_key=True) salary_periods_for_user: Optional[List[\"SalaryPeriodForUser\"]] = Relationship(back_populates=\"user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) waste_periods_for_user: Optional[List[\"WastePeriodForUser\"]] = Relationship(back_populates=\"user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) class ChangePassword(SQLModel): old_password: str new_password: str === \"Salary\" ```Python title=\"Salary\" class SalaryDB(SQLModel): value: float #legal: bool salary_period_for_user_id: Optional[int] = Field(default=None, foreign_key=\"salaryperiodforuser.id\") class SalaryDisplay(SalaryDB): salary_period_for_user: Optional[\"SalaryPeriodForUser\"] = None class Salary(SalaryDB, table=True): id: int = Field(default=None, primary_key=True) date: datetime.datetime salary_period_for_user: Optional[\"SalaryPeriodForUser\"] = Relationship(back_populates=\"salarys\") === \"SalaryPeriod\" ```Python title=\"SalaryPeriod\" class SalaryPeriodDB(SQLModel): date_start: datetime.date date_end: datetime.date class SalaryPeriodDisplay(SalaryPeriodDB): salary_period_for_users: Optional[List[\"SalaryPeriodForUser\"]] = None class SalaryPeriod(SalaryPeriodDB, table=True): id: int = Field(default=None, primary_key=True) salary_period_for_users: Optional[List[\"SalaryPeriodForUser\"]] = Relationship(back_populates=\"salary_period\") === \"SalaryPeriodForUser\" ```Python title=\"SalaryPeriodForUser\" class SalaryPeriodForUserDB(SQLModel): salary_period_id: Optional[int] = Field(default=None, foreign_key=\"salaryperiod.id\") user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") class SalaryPeriodForUserDisplay(SalaryPeriodForUserDB): salary_period: Optional[\"SalaryPeriod\"] = None salarys: Optional[List[\"Salary\"]] = None user: Optional[\"User\"] = None class SalaryPeriodForUser(SalaryPeriodForUserDB, table=True): id: int = Field(default=None, primary_key=True) salary_period: Optional[\"SalaryPeriod\"] = Relationship(back_populates=\"salary_period_for_users\") salarys: Optional[List[\"Salary\"]] = Relationship(back_populates=\"salary_period_for_user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) user: Optional[\"User\"] = Relationship(back_populates=\"salary_periods_for_user\") === \"Waste\" ```Python title=\"Waste\" class Type(Enum): clothes = \"clothes\" meals = \"meals\" hobby = 'hobby' travel = 'travel' class WasteDB(SQLModel): value: float type: Type waste_period_for_user_id: Optional[int] = Field(default=None, foreign_key=\"wasteperiodforuser.id\") class WasteDisplay(WasteDB): waste_period_for_user: Optional[\"WastePeriodForUser\"] = None class Waste(WasteDB, table=True): id: int = Field(default=None, primary_key=True) date: datetime.datetime waste_period_for_user: Optional[\"WastePeriodForUser\"] = Relationship(back_populates=\"wastes\") === \"WastePeriod\" ```Python title=\"WastePeriod\" class WastePeriodDB(SQLModel): date_start: datetime.date date_end: datetime.date class WastePeriodDisplay(WastePeriodDB): waste_period_for_users: Optional[List[\"WastePeriodForUser\"]] = None class WastePeriod(WastePeriodDB, table=True): id: int = Field(default=None, primary_key=True) waste_period_for_users: Optional[List[\"WastePeriodForUser\"]] = Relationship(back_populates=\"waste_period\") === \"WastePeriodForUser\" ```Python title=\"WastePeriodForUser\" class WastePeriodForUserDB(SQLModel): limit: float waste_period_id: Optional[int] = Field(default=None, foreign_key=\"wasteperiod.id\") user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") class WastePeriodForUserDisplay(WastePeriodForUserDB): waste_period: Optional[\"WastePeriod\"] = None wastes: Optional[List[\"Waste\"]] = None user: Optional[\"User\"] = None class WastePeriodForUser(WastePeriodForUserDB, table=True): id: int = Field(default=None, primary_key=True) waste_period: Optional[\"WastePeriod\"] = Relationship(back_populates=\"waste_period_for_users\") wastes: Optional[List[\"Waste\"]] = Relationship(back_populates=\"waste_period_for_user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) user: Optional[\"User\"] = Relationship(back_populates=\"waste_periods_for_user\") ```","title":"\u041c\u043e\u0434\u0435\u043b\u0438 \u0411\u0414"},{"location":"lab1/models/#_1","text":"\u0412 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0438: User - \u041f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u0441\u0435\u0440\u0432\u0438\u0441\u0430 Salary - \u0417\u0430\u0440\u043f\u043b\u0430\u0442\u0430 SalaryPeriod - \u041f\u0435\u0440\u0438\u043e\u0434, \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0441\u0447\u0438\u0442\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0437\u0430\u0440\u043f\u043b\u0430\u0442\u044b SalaryPeriodForUser - \u041f\u0435\u0440\u0438\u043e\u0434 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u0437\u0430\u0440\u043f\u043b\u0430\u0442\u044b \u0434\u043b\u044f \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 Waste - \u0422\u0440\u0430\u0442\u044b WastePeriod - \u041f\u0435\u0440\u0438\u043e\u0434 \u0437\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0441\u0447\u0438\u0442\u0430\u044e\u0442\u0441\u044f \u0442\u0440\u0430\u0442\u044b WastePeriodForUser - \u041f\u0435\u0440\u0438\u043e\u0434 \u0442\u0440\u0430\u0442 \u0434\u043b\u044f \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e\u0433\u043e \u044e\u0437\u0435\u0440\u0430 === \"User\" ```Python title=\"User\" class UserBase(SQLModel): username: str password: str class UserDisplay(UserBase): salary_periods_for_user: Optional[List[\"SalaryPeriodForUser\"]] = None waste_periods_for_user: Optional[List[\"WastePeriodForUser\"]] = None class User(UserBase, table=True): id: int = Field(default=None, primary_key=True) salary_periods_for_user: Optional[List[\"SalaryPeriodForUser\"]] = Relationship(back_populates=\"user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) waste_periods_for_user: Optional[List[\"WastePeriodForUser\"]] = Relationship(back_populates=\"user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) class ChangePassword(SQLModel): old_password: str new_password: str === \"Salary\" ```Python title=\"Salary\" class SalaryDB(SQLModel): value: float #legal: bool salary_period_for_user_id: Optional[int] = Field(default=None, foreign_key=\"salaryperiodforuser.id\") class SalaryDisplay(SalaryDB): salary_period_for_user: Optional[\"SalaryPeriodForUser\"] = None class Salary(SalaryDB, table=True): id: int = Field(default=None, primary_key=True) date: datetime.datetime salary_period_for_user: Optional[\"SalaryPeriodForUser\"] = Relationship(back_populates=\"salarys\") === \"SalaryPeriod\" ```Python title=\"SalaryPeriod\" class SalaryPeriodDB(SQLModel): date_start: datetime.date date_end: datetime.date class SalaryPeriodDisplay(SalaryPeriodDB): salary_period_for_users: Optional[List[\"SalaryPeriodForUser\"]] = None class SalaryPeriod(SalaryPeriodDB, table=True): id: int = Field(default=None, primary_key=True) salary_period_for_users: Optional[List[\"SalaryPeriodForUser\"]] = Relationship(back_populates=\"salary_period\") === \"SalaryPeriodForUser\" ```Python title=\"SalaryPeriodForUser\" class SalaryPeriodForUserDB(SQLModel): salary_period_id: Optional[int] = Field(default=None, foreign_key=\"salaryperiod.id\") user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") class SalaryPeriodForUserDisplay(SalaryPeriodForUserDB): salary_period: Optional[\"SalaryPeriod\"] = None salarys: Optional[List[\"Salary\"]] = None user: Optional[\"User\"] = None class SalaryPeriodForUser(SalaryPeriodForUserDB, table=True): id: int = Field(default=None, primary_key=True) salary_period: Optional[\"SalaryPeriod\"] = Relationship(back_populates=\"salary_period_for_users\") salarys: Optional[List[\"Salary\"]] = Relationship(back_populates=\"salary_period_for_user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) user: Optional[\"User\"] = Relationship(back_populates=\"salary_periods_for_user\") === \"Waste\" ```Python title=\"Waste\" class Type(Enum): clothes = \"clothes\" meals = \"meals\" hobby = 'hobby' travel = 'travel' class WasteDB(SQLModel): value: float type: Type waste_period_for_user_id: Optional[int] = Field(default=None, foreign_key=\"wasteperiodforuser.id\") class WasteDisplay(WasteDB): waste_period_for_user: Optional[\"WastePeriodForUser\"] = None class Waste(WasteDB, table=True): id: int = Field(default=None, primary_key=True) date: datetime.datetime waste_period_for_user: Optional[\"WastePeriodForUser\"] = Relationship(back_populates=\"wastes\") === \"WastePeriod\" ```Python title=\"WastePeriod\" class WastePeriodDB(SQLModel): date_start: datetime.date date_end: datetime.date class WastePeriodDisplay(WastePeriodDB): waste_period_for_users: Optional[List[\"WastePeriodForUser\"]] = None class WastePeriod(WastePeriodDB, table=True): id: int = Field(default=None, primary_key=True) waste_period_for_users: Optional[List[\"WastePeriodForUser\"]] = Relationship(back_populates=\"waste_period\") === \"WastePeriodForUser\" ```Python title=\"WastePeriodForUser\" class WastePeriodForUserDB(SQLModel): limit: float waste_period_id: Optional[int] = Field(default=None, foreign_key=\"wasteperiod.id\") user_id: Optional[int] = Field(default=None, foreign_key=\"user.id\") class WastePeriodForUserDisplay(WastePeriodForUserDB): waste_period: Optional[\"WastePeriod\"] = None wastes: Optional[List[\"Waste\"]] = None user: Optional[\"User\"] = None class WastePeriodForUser(WastePeriodForUserDB, table=True): id: int = Field(default=None, primary_key=True) waste_period: Optional[\"WastePeriod\"] = Relationship(back_populates=\"waste_period_for_users\") wastes: Optional[List[\"Waste\"]] = Relationship(back_populates=\"waste_period_for_user\", sa_relationship_kwargs={ \"cascade\": \"all, delete\", } ) user: Optional[\"User\"] = Relationship(back_populates=\"waste_periods_for_user\") ```","title":"\u041c\u043e\u0434\u0435\u043b\u0438 \u0411\u0414"},{"location":"lab1/routes/","text":"\u0420\u043e\u0443\u0442\u0438\u043d\u0433 \u0422\u043e\u0447\u043a\u0430 \u0432\u0445\u043e\u0434\u0430 \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u0410\u041f\u0418. ```Python title=\"Main\" app = FastAPI() app.include_router(logic_router, prefix=\"/api\", tags=[\"main\"]) app.include_router(auth_router, prefix=\"/api/users\", tags=[\"users\"]) ```","title":"\u0420\u043e\u0443\u0442\u0438\u043d\u0433"},{"location":"lab1/routes/#_1","text":"\u0422\u043e\u0447\u043a\u0430 \u0432\u0445\u043e\u0434\u0430 \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u043c\u0435\u0442\u043e\u0434\u043e\u0432 \u0410\u041f\u0418. ```Python title=\"Main\" app = FastAPI() app.include_router(logic_router, prefix=\"/api\", tags=[\"main\"]) app.include_router(auth_router, prefix=\"/api/users\", tags=[\"users\"]) ```","title":"\u0420\u043e\u0443\u0442\u0438\u043d\u0433"},{"location":"lab2/task-1/","text":"Threads vs Porcess vs Async \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0444\u043e\u043c\u0430\u043d\u0441\u0430 cpu-bound \u0437\u0430\u0434\u0430\u0447 \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 3 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 \u0432 python: multithreading multiprocessing async multithreading import threading import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_threads = 4 n = 1000000 thread_list = [] result = [0] * total_threads step = n // total_threads for i in range(total_threads): start = i * step + 1 end = (i + 1) * step if i != total_threads - 1 else n thread = threading.Thread(target=calculate_partial_sum, args=(start, end, result, i)) thread_list.append(thread) thread.start() for thread in thread_list: thread.join() total_sum = sum(result) return total_sum start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Threading sum: {sum_result}, Time taken: {end_time - start_time} seconds\") multiprocess import multiprocessing import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_processes = 4 n = 1000000 process_list = [] manager = multiprocessing.Manager() result = manager.list([0] * total_processes) step = n // total_processes for i in range(total_processes): start = i * step + 1 end = (i + 1) * step if i != total_processes - 1 else n process = multiprocessing.Process(target=calculate_partial_sum, args=(start, end, result, i)) process_list.append(process) process.start() for process in process_list: process.join() total_sum = sum(result) return total_sum if __name__ == '__main__': start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Multiprocessing sum: {sum_result}, Time taken: {end_time - start_time} seconds\") async import asyncio import time async def calculate_partial_sum(start, end): return sum(range(start, end + 1)) async def calculate_sum(): total_tasks = 4 n = 1000000 step = n // total_tasks tasks = [] for i in range(total_tasks): start = i * step + 1 end = (i + 1) * step if i != total_tasks - 1 else n tasks.append(asyncio.create_task(calculate_partial_sum(start, end))) results = await asyncio.gather(*tasks) total_sum = sum(results) return total_sum start_time = time.time() sum_result = asyncio.run(calculate_sum()) end_time = time.time() print(f\"Async sum: {sum_result}, Time taken: {end_time - start_time} seconds\") \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0437\u0430\u043c\u0435\u0440\u043e\u0432 | Solution | Time (seconds) | |---------------|--------------------| | Async | 1.2993099689483643 | | Multiprocess | 1.6727426052093506 | | Threading | 1.244816780090332 | \u0412\u044b\u0432\u043e\u0434\u044b \u041a\u0430\u043a \u043c\u043e\u0436\u0435\u043c \u0432\u0438\u0434\u0435\u0442\u044c, \u043d\u0430\u0438\u043b\u0443\u0447\u0448\u0438\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u0432 python \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0434\u043e\u0431\u0438\u0442\u044c\u0441\u044f \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 multiprocess, \u0442\u0430\u043a \u043a\u0430\u043a \u043f\u043e \u0441\u0443\u0442\u0438 \u044d\u0442\u043e \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u0430\u044f \u0447\u0435\u0441\u0442\u043d\u0430\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043d\u043e\u0441\u0442\u044c, \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0438\u0442\u044c\u0441\u044f \u0432 python \u0438\u0437-\u0437\u0430 GIL.","title":"Threads vs Porcess vs Async"},{"location":"lab2/task-1/#threads-vs-porcess-vs-async","text":"\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0444\u043e\u043c\u0430\u043d\u0441\u0430 cpu-bound \u0437\u0430\u0434\u0430\u0447 \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 3 \u043f\u043e\u0434\u0445\u043e\u0434\u043e\u0432 \u0432 python: multithreading multiprocessing async","title":"Threads vs Porcess vs Async"},{"location":"lab2/task-1/#multithreading","text":"import threading import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_threads = 4 n = 1000000 thread_list = [] result = [0] * total_threads step = n // total_threads for i in range(total_threads): start = i * step + 1 end = (i + 1) * step if i != total_threads - 1 else n thread = threading.Thread(target=calculate_partial_sum, args=(start, end, result, i)) thread_list.append(thread) thread.start() for thread in thread_list: thread.join() total_sum = sum(result) return total_sum start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Threading sum: {sum_result}, Time taken: {end_time - start_time} seconds\")","title":"multithreading"},{"location":"lab2/task-1/#multiprocess","text":"import multiprocessing import time def calculate_partial_sum(start, end, result, index): result[index] = sum(range(start, end + 1)) def calculate_sum(): total_processes = 4 n = 1000000 process_list = [] manager = multiprocessing.Manager() result = manager.list([0] * total_processes) step = n // total_processes for i in range(total_processes): start = i * step + 1 end = (i + 1) * step if i != total_processes - 1 else n process = multiprocessing.Process(target=calculate_partial_sum, args=(start, end, result, i)) process_list.append(process) process.start() for process in process_list: process.join() total_sum = sum(result) return total_sum if __name__ == '__main__': start_time = time.time() sum_result = calculate_sum() end_time = time.time() print(f\"Multiprocessing sum: {sum_result}, Time taken: {end_time - start_time} seconds\")","title":"multiprocess"},{"location":"lab2/task-1/#async","text":"import asyncio import time async def calculate_partial_sum(start, end): return sum(range(start, end + 1)) async def calculate_sum(): total_tasks = 4 n = 1000000 step = n // total_tasks tasks = [] for i in range(total_tasks): start = i * step + 1 end = (i + 1) * step if i != total_tasks - 1 else n tasks.append(asyncio.create_task(calculate_partial_sum(start, end))) results = await asyncio.gather(*tasks) total_sum = sum(results) return total_sum start_time = time.time() sum_result = asyncio.run(calculate_sum()) end_time = time.time() print(f\"Async sum: {sum_result}, Time taken: {end_time - start_time} seconds\")","title":"async"},{"location":"lab2/task-1/#_1","text":"| Solution | Time (seconds) | |---------------|--------------------| | Async | 1.2993099689483643 | | Multiprocess | 1.6727426052093506 | | Threading | 1.244816780090332 |","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0437\u0430\u043c\u0435\u0440\u043e\u0432"},{"location":"lab2/task-1/#_2","text":"\u041a\u0430\u043a \u043c\u043e\u0436\u0435\u043c \u0432\u0438\u0434\u0435\u0442\u044c, \u043d\u0430\u0438\u043b\u0443\u0447\u0448\u0438\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u0432 python \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0434\u043e\u0431\u0438\u0442\u044c\u0441\u044f \u043f\u0440\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0438 multiprocess, \u0442\u0430\u043a \u043a\u0430\u043a \u043f\u043e \u0441\u0443\u0442\u0438 \u044d\u0442\u043e \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u0430\u044f \u0447\u0435\u0441\u0442\u043d\u0430\u044f \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u043d\u043e\u0441\u0442\u044c, \u043a\u043e\u0442\u043e\u0440\u043e\u0439 \u043c\u043e\u0436\u043d\u043e \u0434\u043e\u0431\u0438\u0442\u044c\u0441\u044f \u0432 python \u0438\u0437-\u0437\u0430 GIL.","title":"\u0412\u044b\u0432\u043e\u0434\u044b"},{"location":"lab2/task-2/","text":"\u041f\u0430\u0441\u0438\u043d\u0433 \u0432\u0435\u0431 \u0441\u0442\u0440\u0430\u043d\u0438\u0446 multithreading from threading import Thread import requests from bs4 import BeautifulSoup import time from dotenv import load_dotenv import random import psycopg2 import os load_dotenv() def save_to_database(url, title): db_url = os.getenv(\"DB_URL\") conn = psycopg2.connect(db_url) curs = conn.cursor() curs.execute(\"INSERT INTO site (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() curs.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title) def main(urls): threads = [] for url in urls: thread = Thread(target=parse_and_save, args=(url,)) threads.append(thread) thread.start() for thread in threads: thread.join() if __name__ == \"__main__\": start_time = time.time() urls = [ f'https://mybooklist.ru/list/{random.randint(100, 1000)}' for _ in range(5) ] main(urls) end_time = time.time() execution_time = end_time - start_time with open('times.txt', 'a') as f: f.write(f\"Tread: {execution_time}\\n\") multiprocess from multiprocessing import Pool import requests from bs4 import BeautifulSoup import psycopg2 import time from dotenv import load_dotenv import os import random load_dotenv() def save_to_database(url, title): db_url = os.getenv(\"DB_URL\") conn = psycopg2.connect(db_url) curs = conn.cursor() curs.execute(\"INSERT INTO site (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() curs.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title) def main(urls): num_process = len(urls) if len(urls) < 4 else 4 pool = Pool(processes=num_process) pool.map(parse_and_save, urls) if __name__ == \"__main__\": start_time = time.time() urls = [ f'https://mybooklist.ru/list/{random.randint(100, 1000)}' for _ in range(5) ] main(urls) end_time = time.time() execution_time = end_time - start_time with open('times.txt', 'a') as f: f.write(f\"Multiprocess: {execution_time}\\n\") async import aiohttp import asyncio import asyncpg from bs4 import BeautifulSoup import time from dotenv import load_dotenv import random load_dotenv() async def save_to_db(data): conn = await asyncpg.connect(os.getenv(\"DB_URL\")) try: await conn.execute( \"INSERT INTO parce (url, title, process_type) VALUES ($1, $2, $3)\", data['url'], data['title'], 'async' ) finally: await conn.close() async def parse_and_save(url): async with aiohttp.ClientSession() as session: async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') title = soup.find('title').text await save_to_db({'url': url, 'title': title}) async def main(urls): tasks = [] for url in urls: task = asyncio.create_task(parse_and_save(url)) tasks.append(task) await asyncio.gather(*tasks) if __name__ == \"__main__\": start_time = time.time() urls = [ f'https://mybooklist.ru/list/{random.randint(100, 1000)}' for _ in range(5) ] asyncio.run(main(urls)) end_time = time.time() execution_time = end_time - start_time with open('times.txt', 'a') as f: f.write(f\"Async: {execution_time}\\n\") \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0437\u0430\u043c\u0435\u0440\u043e\u0432 | Solution | Time (seconds) | |---------------|--------------------| | Async | 1.2993099689483643 | | Multiprocess | 1.6727426052093506 | | Threading | 1.244816780090332 |","title":"\u041f\u0430\u0441\u0438\u043d\u0433 \u0432\u0435\u0431 \u0441\u0442\u0440\u0430\u043d\u0438\u0446"},{"location":"lab2/task-2/#_1","text":"","title":"\u041f\u0430\u0441\u0438\u043d\u0433 \u0432\u0435\u0431 \u0441\u0442\u0440\u0430\u043d\u0438\u0446"},{"location":"lab2/task-2/#multithreading","text":"from threading import Thread import requests from bs4 import BeautifulSoup import time from dotenv import load_dotenv import random import psycopg2 import os load_dotenv() def save_to_database(url, title): db_url = os.getenv(\"DB_URL\") conn = psycopg2.connect(db_url) curs = conn.cursor() curs.execute(\"INSERT INTO site (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() curs.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title) def main(urls): threads = [] for url in urls: thread = Thread(target=parse_and_save, args=(url,)) threads.append(thread) thread.start() for thread in threads: thread.join() if __name__ == \"__main__\": start_time = time.time() urls = [ f'https://mybooklist.ru/list/{random.randint(100, 1000)}' for _ in range(5) ] main(urls) end_time = time.time() execution_time = end_time - start_time with open('times.txt', 'a') as f: f.write(f\"Tread: {execution_time}\\n\")","title":"multithreading"},{"location":"lab2/task-2/#multiprocess","text":"from multiprocessing import Pool import requests from bs4 import BeautifulSoup import psycopg2 import time from dotenv import load_dotenv import os import random load_dotenv() def save_to_database(url, title): db_url = os.getenv(\"DB_URL\") conn = psycopg2.connect(db_url) curs = conn.cursor() curs.execute(\"INSERT INTO site (url, title) VALUES (%s, %s)\", (url, title)) conn.commit() curs.close() conn.close() def parse_and_save(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') title = soup.find('title').text save_to_database(url, title) def main(urls): num_process = len(urls) if len(urls) < 4 else 4 pool = Pool(processes=num_process) pool.map(parse_and_save, urls) if __name__ == \"__main__\": start_time = time.time() urls = [ f'https://mybooklist.ru/list/{random.randint(100, 1000)}' for _ in range(5) ] main(urls) end_time = time.time() execution_time = end_time - start_time with open('times.txt', 'a') as f: f.write(f\"Multiprocess: {execution_time}\\n\")","title":"multiprocess"},{"location":"lab2/task-2/#async","text":"import aiohttp import asyncio import asyncpg from bs4 import BeautifulSoup import time from dotenv import load_dotenv import random load_dotenv() async def save_to_db(data): conn = await asyncpg.connect(os.getenv(\"DB_URL\")) try: await conn.execute( \"INSERT INTO parce (url, title, process_type) VALUES ($1, $2, $3)\", data['url'], data['title'], 'async' ) finally: await conn.close() async def parse_and_save(url): async with aiohttp.ClientSession() as session: async with session.get(url) as response: html = await response.text() soup = BeautifulSoup(html, 'html.parser') title = soup.find('title').text await save_to_db({'url': url, 'title': title}) async def main(urls): tasks = [] for url in urls: task = asyncio.create_task(parse_and_save(url)) tasks.append(task) await asyncio.gather(*tasks) if __name__ == \"__main__\": start_time = time.time() urls = [ f'https://mybooklist.ru/list/{random.randint(100, 1000)}' for _ in range(5) ] asyncio.run(main(urls)) end_time = time.time() execution_time = end_time - start_time with open('times.txt', 'a') as f: f.write(f\"Async: {execution_time}\\n\")","title":"async"},{"location":"lab2/task-2/#_2","text":"| Solution | Time (seconds) | |---------------|--------------------| | Async | 1.2993099689483643 | | Multiprocess | 1.6727426052093506 | | Threading | 1.244816780090332 |","title":"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u044b \u0437\u0430\u043c\u0435\u0440\u043e\u0432"},{"location":"lab3/celery/","text":"\u0421\u0435\u0440\u0432\u0438\u0441 \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430 celery function import threading import requests from bs4 import BeautifulSoup import time from db import Parce from celery import Celery celery_app = Celery( \"worker\", broker=\"redis://redis:6379/0\", backend=\"redis://redis:6379/0\", ) celery_app.conf.update( task_routes={ \"parse.parse_and_save\": \"main-queue\", }, ) @celery_app.task def parse_and_save(url, session): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No title' new_article = Parce( url = url, article_title = title ) session.add(new_article) session.commit()","title":"\u0421\u0435\u0440\u0432\u0438\u0441 \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430"},{"location":"lab3/celery/#_1","text":"","title":"\u0421\u0435\u0440\u0432\u0438\u0441 \u043f\u0430\u0440\u0441\u0438\u043d\u0433\u0430"},{"location":"lab3/celery/#celery-function","text":"import threading import requests from bs4 import BeautifulSoup import time from db import Parce from celery import Celery celery_app = Celery( \"worker\", broker=\"redis://redis:6379/0\", backend=\"redis://redis:6379/0\", ) celery_app.conf.update( task_routes={ \"parse.parse_and_save\": \"main-queue\", }, ) @celery_app.task def parse_and_save(url, session): response = requests.get(url) soup = BeautifulSoup(response.content, 'html.parser') title = soup.title.string if soup.title else 'No title' new_article = Parce( url = url, article_title = title ) session.add(new_article) session.commit()","title":"celery function"},{"location":"lab3/docker/","text":"\u0414\u043e\u043a\u0435\u0440 FROM python:3.10-alpine3.19 WORKDIR /lab_1 COPY . . RUN pip3 install -r requirements.txt CMD uvicorn main:app --host localhost --port 8000 version: '3.10' services: taskmanager: container_name: lab_1 build: context: ./lab_1 env_file: .env depends_on: - db ports: - \"8000:8000\" command: uvicorn main:app --host 0.0.0.0 --port 8000 networks: - backend_3 restart: always lab_2: container_name: lab_2 build: context: ./lab_2 env_file: .env restart: always ports: - \"8001:8001\" command: uvicorn main:app --host 0.0.0.0 --port 8001 depends_on: - redis - db networks: - backend_3 celery_start: build: context: ./lab_2 container_name: celery_start command: celery -A celery_start worker --loglevel=info restart: always depends_on: - redis - lab_2 - db networks: - backend_3 redis: image: redis ports: - \"6379:6379\" networks: - backend_3 depends_on: - db db: image: postgres restart: always environment: - POSTGRES_PASSWORD=postgres - POSTGRES_USER=postgres - POSTGRES_DB=test_db volumes: - postgres_data:/var/lib/postgresql/data/ ports: - \"5432:5432\" networks: - backend_3 volumes: postgres_data: networks: backend_3: driver: bridge","title":"\u0414\u043e\u043a\u0435\u0440"},{"location":"lab3/docker/#_1","text":"FROM python:3.10-alpine3.19 WORKDIR /lab_1 COPY . . RUN pip3 install -r requirements.txt CMD uvicorn main:app --host localhost --port 8000 version: '3.10' services: taskmanager: container_name: lab_1 build: context: ./lab_1 env_file: .env depends_on: - db ports: - \"8000:8000\" command: uvicorn main:app --host 0.0.0.0 --port 8000 networks: - backend_3 restart: always lab_2: container_name: lab_2 build: context: ./lab_2 env_file: .env restart: always ports: - \"8001:8001\" command: uvicorn main:app --host 0.0.0.0 --port 8001 depends_on: - redis - db networks: - backend_3 celery_start: build: context: ./lab_2 container_name: celery_start command: celery -A celery_start worker --loglevel=info restart: always depends_on: - redis - lab_2 - db networks: - backend_3 redis: image: redis ports: - \"6379:6379\" networks: - backend_3 depends_on: - db db: image: postgres restart: always environment: - POSTGRES_PASSWORD=postgres - POSTGRES_USER=postgres - POSTGRES_DB=test_db volumes: - postgres_data:/var/lib/postgresql/data/ ports: - \"5432:5432\" networks: - backend_3 volumes: postgres_data: networks: backend_3: driver: bridge","title":"\u0414\u043e\u043a\u0435\u0440"}]}